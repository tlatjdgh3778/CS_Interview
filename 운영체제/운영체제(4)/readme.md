# 9. 가상 메모리
가상 메모리는 어떤 프로세스를 실행할 때 프로세스 전체가 메모리에 적재되지 않고도 실행이 가능하도록 하는 기법이다. 어떤 프로세스가 차지하는 메모리가 전체 메모리 용량보다 크더라도 지금 당장 필요한 부분만 메모리에 적재되면 실행이 가능하기 때문에 메모리 용량을 초과해도 동작이 가능하도록 할 수 있는 장점이 있다.

가상 메모리는 실제의 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것으로 정리할 수 있다. 작은 메모리를 가지고도 얼마든지 큰 가장 주소 공간을 제공할 수 있는 장점이 있다.

<p align="center"><img src="https://t1.daumcdn.net/cfile/tistory/224F144E590E8AD91B"></p>

## 9-1. 요구 페이징
프로세스를 페이지 단위로 잘라서 메모리에 올리는데 요구되는 페이지만 메모리에 올리고 필요하지 않은 페이지들은 backing store(하드디스크)에 저장해주는 것이다.

요구 페이징을 스와핑 기법과 유사하다. 프로세스를 실행하고 싶으면 메모리로 읽어 들이며 이 때 전체 프로세스를 읽어오지 않고 lazy swapper를 사용한다. lazy swapper는 그 페이지가 필요하지 않는 한 메모리에 적재되지 않는다.

> 메모리에 적재된 페이지 중에 사용페이지가 없을 때를 **페이지 부재** 라고 한다.

## 9-2. 페이지 교체
프로그램이 실행이 계속 진행되면 요구 페이지가 늘어나게 되고 언젠가는 메모리가 가득 차게 될 것이다. 페이지를 backing store에서 가져와 메모리에 올려야 되는데 메모리에 자리가 없는 것이다. 이 경우 메인 메모링 있는 특정 페이지를 내보낼 필요가 있다. 그 자리에 필요한 다른 페이지를 올리는 것을 **페이지 교체** 라고 한다.

<p align="center"><img src="https://t1.daumcdn.net/cfile/tistory/266938385913F71805"></p>

메모리가 가득 차면 추가로 페이지를 가져오기 위해 어떤 페이지는 backing store로 몰아내고 그 빈 공간으로 페이지를 가져온다. backing store로 페이지를 몰아내는 것을 page-out 이라고 하고 반대로 빈 공간으로 페이지를 가져오는 것을 page-in 이라고 한다.

## 9-3.페이지 교체 알고리즘
### First In First Out(FIFO)
FIFO 방식은 대기열의 맨 앞에 있는 페이지, 즉 가장 오랫동안 **메모리에 있었던 페이지**를 교체한다.

크기가 12인 페이지(1, 2, 3, 4, 5, 1, 3, 1, 6, 3, 2, 3) 와 프레임 크기 4인 경우

<p align="center"><img src="https://s3.ap-south-1.amazonaws.com/afteracademy-server-uploads/what-are-the-page-replacement-algorithms-fifo-bbf705290d1e6776.jpg"></p>

페이지 부재 = **9**

* 1,2,3,4 가 순서대로 들어온다.
* 5가 오면 가장 오래된 페이지 1을 교체한다.
* 1이 오면 가장 오래된 페이지 2를 교체한다.
* 3이 오면 교체하지 않는다.
* 1이 오면 교체하지 않는다.
* 6이 오면 가장 오래된 페이지 3을 교체한다.
* 3이 오면 가장 오래된 페이지 4를 교체한다.
* 2가 오면 가장 오래된 페이지 5을 교체한다.
* 3이 오면 교체하지 않는다.

### Least Recently Used(LRU)
LRU 방식은 최근에 가장 오랫동안 **사용되지 않은 페이지**를 교체하는 방식이다.

크기가 12인 페이지(1, 2, 3, 4, 5, 1, 3, 1, 6, 3, 2, 3) 와 프레임 크기 4인 경우

<p align="center"><img src="https://s3.ap-south-1.amazonaws.com/afteracademy-server-uploads/what-are-the-page-replacement-algorithms-lru-0e258594b2dec232.jpg"></p>

페이지 부재 = **8**

* 1,2,3,4 가 순서대로 들어온다.
* 5가 오면 가장 최근에 사용된 페이지 1을 교체한다.
* 1이 오면 가장 최근에 사용된 페이지 2를 교체한다.
* 3이 오면 교체하지 않는다.
* 1이 오면 교체하지 않는다.
* 6이 오면 가장 최근에 사용된 페이지 4를 교체한다.
* 3이 오면 교체하지 않는다.
* 2가 오면 가장 최근에 사용된 페이지 5를 교체한다.
* 3이 오면 교체하지 않는다.

### Optimal Replacement(OPT)
OPT(최적 교체) 방식을 미래를 보고 앞으로 가장 사용이 안 될 페이지를 교체하는 방식이다.
이 방식은 프로세스가 앞으로 사용할 페이지를 **미리** 알아야 한다는 전제조건이 있다.
실제로는 미래를 알 수는 없기 때문에 구현은 불가능하다고 한다.

크기가 12인 페이지(1, 2, 3, 4, 5, 1, 3, 1, 6, 3, 2, 3) 와 프레임 크기 4인 경우

<p align="center"><img src="https://s3.ap-south-1.amazonaws.com/afteracademy-server-uploads/what-are-the-page-replacement-algorithms-optimal-8e02fc8a1f4517de.jpg"></p>

페이지 부재 = **6**

* 1,2,3,4 가 순서대로 들어온다.
* 5가 오면 1,2,3,4 중 미래에 사용이 안 될 4를 교체한다.
* 1이 오면 교체하지 않는다.
* 3이 오면 교체하지 않는다.
* 1이 오면 교체하지 않는다.
* 6이 오면 1을 교체한다.
* 3이 오면 교체하지 않는다.
* 2가 오면 교체하지 않는다.
* 3이 오면 교체하지 않는다.

# 참고
* https://copycode.tistory.com/113?category=740133
* https://afteracademy.com/blog/what-are-the-page-replacement-algorithms
