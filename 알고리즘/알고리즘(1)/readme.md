# 알고리즘(1)

# 1. 빅오(Big-O) 표기법
빅오(Big-O) 표기법은 알고리즘의 성능을 수학적으로 표현해주는 표기법이다. 이를 이용해 알고리즘의 **시간 복잡도(Time Complexity)** 와 **공간 복잡도(Space Complexity)** 를 나타낼 수 있다.

빅오 표기법은 입력 데이터 값(n)이 아주 큰 값으로 들어온다고 가정을 하기 때문에 아래와 같은 규칙이 가능하다.

* **상수항 무시**
  * n이 아주 큰 값으로 커지게 되면 상수항을 무시할 수 있다.
  * O(2n) -> O(n)
* **최고차항만 표기**
  * 결과에 가장 큰 영향을 미치는 최고차항만 남기고 나머지는 무시할 수 있다.
  * O(3n^2 + 2n + 5) -> O(n^2)
  
## 1-1. 시간 복잡도와 공간 복잡도
### 시간 복잡도(Time Complexity)
시간 복잡도란 빅오 표기법에 대한 시간 개념으로 알고리즘을 수행하는 데에 연산들이 몇 번 이루어지는 지를 숫자로 표현하는 방법이다.

연산의 종류는 산술, 대입, 비교, 이동을 말한다.

### 공간 복잡도(Space Complexity)
공간에 대한 개념으로 알고리즘이 공간을 얼마나 필요로 하는지를 나타낸다. 

크기가 N인 배열을 만든다고 가정하면 공간 복잡도는 O(N)이 되고 NxN인 배열을 만들면 공간 복잡도는 O(N^2)가 된다.

## 1-2. 빅오 표기법의 종류

<p align="center"><img src="https://t1.daumcdn.net/cfile/tistory/99EF1E395C7EB4B601"></p>

* O(1)
  * 입력 데이터의 크기와 상관없이 언제나 일정한 시간이 걸린다.
* O(logn)
  * 로그는 매우 큰 입력값에서도 큰 영향을 받지 않는다. 이진 탐색의 경우가 여기에 해당한다.
* O(n)
  * 입력 데이터의 크기에 비례해서 알고리즘의 수행시간이 늘어난다. 
* O(nlogn)
  * 병합정렬, 힙정렬 등의 알고리즘에 여기에 해당한다.
* O(n^2)
  * 입력 데이터의 크기(n)의 제곱만큼의 수행시간이 걸리는 알고리즘(버블정렬 등)이 있다.
* O(2^n)
  * 피보나치의 수를 재귀로 구현하는 경우 이러한 수행시간이 걸린다. 

이 외에도 더 많은 표기법들이 있겠지만 대표적인 것들만 정리해봤다.

# 2. 정렬 알고리즘
정렬 알고리즘은 원소들을 번호순이나 사전 순서와 같이 일정한 순서대로 정렬하는 알고리즘이다. 많은 종류의 알고리즘들이 있지만 여기서는 유명한 정렬 알고리즘 몇 개 정도만 정리한다.

## 2-1. 버블 정렬(Bubble Sort)
버블 정렬(거품 정렬)은 1956년에 분석된 아주 오래된 알고리즘으로 그만큼 시간이 오래걸린다는 단점이 있지만 구현은 아주 간단하다.

버블 정렬은 서로 인접한 두 원소를 검사하여 정렬하는 방식을 사용한다. 첫 루프를 돌면 가장 큰 원소가 맨 뒤로 이동하므로 두 번째 루프에서는 맨 뒤의 원소는 제외된다.

정렬이 진행되는 과정을 보자

<p align="center"><img src="https://cdn-images-1.medium.com/max/1600/1*ZQmdM7My9QIhvxj98hrweg.gif"></p>

### 시간 복잡도
시간 복잡도는 첫 번째 루프에서 (n-1)번 두 번째 루프에서 (n-2)번... 마지막 루프에서 1번 즉 n(n-1)/2 => **O(n^2)** 의 시간 복잡도가 나온다.

버블 정렬은 정렬이 되어있던 되어있지 않던 2개의 원소를 비교하기 때문에 시간 복잡도는 모두**O(n^2)** 가 나온다.

### 공간 복잡도
주어진 배열 안에서 swap하기 때문에 **O(n)** 의 공간 복잡도를 가진다.

## 2-2. 선택 정렬(Selection Sort)
선택 정렬은 전체 원소들 중에서 기준 위치에 맞는 원소를 선택하여 자리를 교환하는 방식이다.

오름차순 기준

주어진 리스트에서 최소값을 찾고 최소값과 맨 앞에 위치한 값과 swap 한다.
그 다음부터는 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.

<p align="center"><img src="https://cdn-images-1.medium.com/max/1600/1*to7gYwi5_bkZhx-1kSB0Lg.gif"></p>

### 시간 복잡도
비교횟수는 버블 정렬과 동일하게 n(n-1)/2이므로 **O(n^2)** 의 시간 복잡도를 가진다.

### 공간 복잡도
주어진 배열 안에서 swap하기 때문에 **O(n)** 의 공간 복잡도를 가진다.

## 2-3. 삽입 정렬(Insertion Sort)
삽입 정렬은 1번 인덱스부터 시작하여 현재위치보다 아래쪽을 순회하여 알맞은 위치에 넣어주는 알고리즘이다.

두 번째부터 뽑아서 그 숫자가 첫 번째보다 크면 첫 번째 숫자의 오른쪽에, 작으면 왼쪽에 넣는다. 그리고 세 번째 숫자를 뽑아서 앞의 두 숫자와 크기를 비교하고 알맞은 자리에 넣는다.

<p align="center"><img src="https://cdn-images-1.medium.com/max/1600/1*IK3Q4NBRLthllMINV3OxpQ.gif"></p>

### 시간 복잡도
최악의 경우(역으로 정렬되어 있는 경우)에 선택 정렬과 마찬가지로 n(n-1)/2 => **O(n^2)** 의 시간 복잡도를 가진다.

하지만 모두 정렬이 되어 있는 경우에는 한 번씩 비교만 하고 끝나기에 **O(n)** 의 시간 복잡도를 가진다.

즉 최선의 경우는 **O(n)**, 평균과 최악의 경우는 **O(n^2)** 의 시간 복잡도를 가진다.

### 공간 복잡도
주어진 배열 안에서 swap 하기 때문에 **O(n)** 의 공간 복잡도를 가진다.

## 2-4. 병합 정렬

## 2-5. 퀵 정렬
## 2-6. 힙 정렬
# 재귀
# 다이나믹 프로그래밍
# 피보나치(재귀 dp 반복문)
# 참고
* https://jinhyy.tistory.com/9
* https://gyoogle.dev/blog/algorithm/Selection%20Sort.html
